{
  "version": 3,
  "sources": ["../src/utils/path.js", "../src/utils/mimeTypes.js", "../src/utils/defaults.js", "../src/utils/nodeModules.js", "../src/utils/sourceMap.js", "../src/utils/transformations.js", "../src/utils/errors.js", "../src/utils/handlers.js", "../src/utils/request.js", "../src/utils/response.js", "../src/utils/load.js", "../src/Bundle.js", "../src/utils/encode/index.js", "../src/utils/encode/datauri.js", "../src/utils/encode/objecturl.js", "../src/utils/compile.js", "../src/utils/polyfills.js", "../src/index.js"],
  "sourcesContent": ["import * as mimeTypes from './mimeTypes.js'\nimport defaults from './defaults.js'\n\nconst urlSep = '://'\n\nexport const get = (path, rel = '', keepRelativeImports=false, isDirectory = false) => {\n\n    if (url(path)) return path\n    // if (!path.includes('./')) rel = '' // absolute\n\n    let prefix = ''\n    const getPrefix = (str) => {\n        prefix = (str.includes(urlSep)) ? str.split(urlSep).splice(0,1) : undefined\n        if (prefix) return str.replace(`${prefix}${urlSep}`, '')\n        else return str\n    }\n\n    if (path.includes(urlSep)) path = getPrefix(path)\n    if (rel.includes(urlSep)) rel = getPrefix(rel)\n\n    if (!keepRelativeImports) rel = rel.split('/').filter(v => v != '..').join('/') // Remove leading ..\n\n    if (rel[rel.length - 1] === '/') rel = rel.slice(0, -1) // Remove trailing slashes\n\n    let dirTokens = rel.split('/')\n    if (dirTokens.length === 1 && dirTokens[0] === '') dirTokens = [] // Remove consequence of empty string rel\n\n    if (!isDirectory){\n        const potentialFile = dirTokens.pop() // remove file name\n        if (potentialFile) {\n            const splitPath = potentialFile.split('.')\n        if (splitPath.length == 1 || (splitPath.length > 1 && splitPath.includes(''))) dirTokens.push(potentialFile) // ASSUMPTION: All files have an extension\n        }\n    }\n\n    const splitPath = path.split(\"/\")\n    const pathTokens = splitPath.filter((str, i) => !!str) // remove bookend slashes\n\n    const extensionTokens = pathTokens.filter((str, i) => {\n        if (str === '..') {\n            dirTokens.pop() // Pop off directories\n            return false\n        } else if (str === '.') return false\n        else return true\n    })\n\n    // Concatenate with windowLocation if rel matched OR no rel and path matched...\n    const newPath = [...dirTokens, ...extensionTokens].join('/')\n\n\n    // Add prefix back if it exists\n    if (prefix) return prefix + '://' + newPath\n    else return newPath\n}\n\n\nexport function absolute(uri, urlWorks) {\n    const absolutePath = uri[0] !== \".\";\n    const isRemote = url(uri);\n    return absolutePath && (urlWorks || !isRemote)\n}\n\nexport function url(uri) {\n    try {\n        new URL(uri)\n        return true\n    } catch {\n        return false\n    }\n}\n\nexport const extension = (path) => {\n    const ext = path.split('/').slice(-1)[0].split(\".\").slice(-1)[0];\n    if (mimeTypes.map[ext]) return ext\n}\n\n\n// Remove File Name\nexport const base = (str) => str.substring(0, str.lastIndexOf(\"/\"));\n\n\nexport const noBase = (path, opts, removeNode) => {\n\n    path = (globalThis.location) ? path.replace(`${base(globalThis.location.href)}/`, \"./\") : path\n\n    const absolutePath = absolute(path, true)\n    const relativeTo = opts.relativeTo ?? defaults.nodeModules.relativeTo\n    const nodeModulePath = opts.nodeModules ?? defaults.nodeModules.nodeModules\n    \n    // Pass Absolute\n    if (absolutePath) return path\n\n    // Keep Relative\n    else {\n        let noBase = path\n        if (removeNode) noBase = noBase.replace(`${nodeModulePath}/`, \"\")\n        noBase = noBase.replace(`${relativeTo.split(\"/\").slice(0, -1).join(\"/\")}/`, \"\");\n        if (noBase[0] !== '.') noBase = `./${noBase}`\n        return noBase\n    }\n}\n\nexport const pathId = (path, opts) => get(noBase(path,opts))\n\n", "// Mime Type Resolution\nexport const js = 'application/javascript'\nexport const isJS = (type) => !type || type === 'application/javascript'\nexport const map = {\n    'js': js,\n    'mjs': js,\n    'cjs': js,\n    \"ts\": \"text/typescript\",\n    'json': \"application/json\",\n    'html': 'text/html',\n    'css': 'text/css',\n    'txt': 'text/plain',\n    'svg': 'image/svg+xml',\n    'png': 'image/png',\n    'jpg': 'image/jpeg',\n    'jpeg': 'image/jpeg',\n    'gif': 'image/gif',\n    'webp': 'image/webp',\n\n    'mp3': 'audio/mpeg',\n    'mp4': 'video/mp4',\n    'webm': 'video/webm',\n    'ogg': 'application/ogg',\n    'wav': 'audio/wav'\n}\n\nexport const get = (extension) => map[extension]\n", "export default {\n    nodeModules: {\n        nodeModules: \"node_modules\",\n        relativeTo: \"./\"\n    }\n}", "import * as pathUtils from './path.js'\nimport defaults from './defaults.js'\n\nexport const path = (opts) => {\n    const nodeModules = opts.nodeModules ?? defaults.nodeModules.nodeModules;\n    const relativeTo = opts.relativeTo ?? defaults.nodeModules.relativeTo;\n    return pathUtils.get(nodeModules, relativeTo)\n}\n\nexport const resolve = async (uri, opts) => {\n    const absoluteNodeModules = path(opts)\n\n    const split = uri.split('/')\n    let base = pathUtils.get(uri, absoluteNodeModules);\n\n\n    if (split.length > 1) {\n        const hasExt = pathUtils.extension(base)\n        if (hasExt) return base // not a base node-module\n        else base += '/package.json' // otherwise might have an associated package.json\n    }\n\n\n    return await getMainPath(uri, base, opts).catch(e => {\n        console.warn(`${base} does not exist or is not at the root of the project.`);\n    })\n};\n\nconst getPath = (str, path, base) => pathUtils.get(str, base, false, path.split(\"/\").length === 1);\n\nconst getPackagePath = (path, base = path) => getPath(\"package.json\", path, base)\n\nexport const getMainPath = async (path, base = path, opts={}) => {\n    const pkg = await getPackage(path, base, opts)\n    if (!pkg) return base\n    const destination = pkg.module || pkg.main || \"index.js\";\n    return getPath(destination, path, base);\n}\n\nconst getPackage = async (path, base = path, opts) => {\n    const pkgPath = getPackagePath(path, base)\n    const isURL = pathUtils.url(pkgPath)\n    const correct = isURL ? pkgPath : new URL(pkgPath, window.location.href).href\n        // const correct = isURL ? pkgPath : pathUtils.get(pkgPath, opts)\n\n    return (await import(correct, { assert: { type: \"json\" } })).default;\n}\n\n// Export the Related Transformation\nexport const transformation = {\n    name: 'node_modules',\n    handler: resolve\n}\n", "import * as pathUtils from './path.js'\nimport * as response from './response.js'\n\n// source map regex\nconst sourceReg = /\\/\\/# sourceMappingURL=(.*\\.map)/\n\nexport const get = async (uri, opts, text, evaluate = true) => {\n\n    if (!text) {\n        const info = await response.get(uri, opts) // get text\n        text = info.text.original\n    }\n\n    if (text) {\n        const srcMap = text.match(sourceReg)\n\n        if (srcMap) {\n            const getMap = async () => {\n                const loc = pathUtils.get(srcMap[1], uri);\n                let info = await response.get(loc, opts) // get text\n                let newText = info.text.original\n\n                // remove source map invalidation\n                if (newText.slice(0, 3) === \")]}\") {\n                    console.warn('Removing source map invalidation characters')\n                    newText = newText.substring(newText.indexOf('\\n'));\n                }\n\n                // return source map\n                const outInfo = { result: JSON.parse(newText) }\n                outInfo.text = {original: newText, updated: null}\n                return outInfo\n            }\n\n            return evaluate ? getMap() : getMap\n        }\n    }\n}", "import { transformation } from \"./nodeModules.js\"\nimport * as pathUtils from \"./path.js\"\n\nconst extensionTransformations = ['ts', 'js']\n\nconst allTransformations = [...extensionTransformations, transformation]\n\n\nexport const get = (uri) => {\n    const pathExt = pathUtils.extension(uri)\n    const abs = pathUtils.absolute(uri)\n    const baseNodeModule = (abs) ? uri.split('/').length === 1 : false\n\n    const noExt = !pathExt\n\n\n    // Both Extension and Path Change (Potential Node Modules)\n    if (!baseNodeModule && abs && noExt) {\n\n        const mapped = extensionTransformations.map(ext => {\n\n            return {\n                extension: ext,\n                name: `${transformation.name} + ${ext}`,\n                handler: transformation.handler\n            }\n        })\n\n        // Likely a Node Module (package.json)\n        if (uri.split('/').length === 1) return [transformation, ...mapped]\n\n        // Likely a File. Maybe a Node Module (package.json)\n        else return [...mapped, transformation]\n    }\n\n    // Path Change First\n    else if (abs) return [...allTransformations].reverse()\n\n    // Extension Changes First\n    else if (noExt) return [...allTransformations]\n\n    else return []\n}", "const middle = \"was not resolved locally. You can provide a direct reference to use in\";\nexport const create = (uri, key = uri) => new Error(`${uri} ${middle} options.filesystem._fallbacks['${key}'].`)", "import * as errors from './errors.js'\nimport * as pathUtils from './path.js';\n\nexport const noExtension = (path, repExt = 'js') => {\n    const absolutePath = pathUtils.absolute(path);\n    const split = path.split('/')\n    const ext = pathUtils.extension(path)\n    if (!absolutePath || (absolutePath && split.length > 1)) {\n        if (!ext) return `${path}.${repExt}` // use alternative extension\n    }\n\n    return path\n}\n\nexport const transformation = async (path, transformation, opts, force) => {\n    const type = typeof transformation\n    if (type === 'string' && (!force || force === 'string')) {\n        return noExtension(path, transformation)\n    }\n    else if (type === 'object' && (!force || force === 'object')) {\n        if (transformation.extension) path = noExtension(path, transformation.extension) // first transform with the extension\n        return await transformation.handler(path, opts).catch(e => {\n            throw errors.create(path, pathUtils.noBase(path, opts))\n        })\n    }\n}", "import * as pathUtils from \"./path.js\"\n\nexport const getURL = (path) => {\n    let url\n    try { url = new URL(path).href }\n    catch { url = pathUtils.get(path, globalThis.location.href) }\n    return url\n}\n\nexport const handleFetch = async (path, options = {}) => {\n    if (!options.fetch) options.fetch = {}\n    if (!options.fetch.mode) options.fetch.mode = 'cors' // Auto-CORS Support\n    const url = getURL(path)\n\n    const progressCallback = options?.callbacks?.progress?.fetch\n\n    const info = await fetchRemote(url, options, {\n        path,\n        progress: progressCallback\n    })\n    if (!info.buffer) throw new Error('No response received.')\n    const type = info.type.split(';')[0] // Get mimeType (not fully specified)\n\n    return {\n        ...info,\n        url,\n        type,\n    }\n}\n\nexport const fetchRemote = async (url, options = {}, additionalArgs) => {\n\n    const path = additionalArgs.path ?? url\n    const pathId = pathUtils.get(pathUtils.noBase(path, options))\n\n    const response = await globalThis.fetch(url, options.fetch)\n\n    let bytesReceived = 0\n    let buffer = [];\n    let bytes = 0;\n\n    const hasProgressFunction  = typeof additionalArgs.progress === 'function'\n    const info = await new Promise(async (resolve) => {\n\n        if (response) {\n\n\n            bytes = parseInt(response.headers.get('Content-Length'), 10)\n            const type = response.headers.get('Content-Type')\n\n            // Browser Remote Parser\n            if (globalThis.REMOTEESM_NODE) {\n                const buffer = await response.arrayBuffer()\n                resolve({ buffer, type })\n            }\n\n            // Browser Remote Parser\n            else {\n\n                const reader = response.body.getReader();\n\n                const processBuffer = async ({ done, value }) => {\n\n                    if (done) {\n                        const config = {}\n                        if (typeof type === 'string') config.type = type\n                        const blob = new Blob(buffer, config)\n                        const ab = await blob.arrayBuffer()\n                        resolve({ buffer: new Uint8Array(ab), type })\n                        return;\n                    }\n\n                    bytesReceived += value.length;\n                    const chunk = value;\n                    buffer.push(chunk);\n\n                    if (hasProgressFunction) additionalArgs.progress(pathId, bytesReceived, bytes, null, null, response.headers.get('Range'))\n\n                    // Read some more, and call this function again\n                    return reader.read().then(processBuffer)\n                }\n\n                reader.read().then(processBuffer)\n            }\n\n        } else {\n            console.warn('Response not received!', options.headers)\n            resolve(undefined)\n        }\n    })\n\n\n    const output = {\n        response,\n        ...info\n    }\n\n    if (hasProgressFunction) {\n        const status = [null, null]\n        if (response.ok) status[0] = output\n        else status[1] = output\n        additionalArgs.progress(pathId, bytesReceived, bytes, ...status, response.headers.get('Range')) // Send Done\n    }\n\n\n    return output\n}", "import * as transformations from './transformations.js'\nimport * as handlers from './handlers.js'\nimport * as pathUtils from \"./path.js\";\nimport { handleFetch } from \"./request.js\";\n\n// Get ESM Module Info\nconst enc = new TextDecoder(\"utf-8\");\nexport const get = async (uri, opts, expectedType) => {\n\n    // Node\n    const info = { uri, text: {original: '', updated: ''}, buffer: null }\n    if (globalThis.REMOTEESM_NODE){\n        const absPath = uri.replace('file://', '')\n        info.buffer = globalThis.fs.readFileSync(absPath)\n        info.text.original = info.text.updated = enc.decode(info.buffer)\n    } \n\n    // Browser\n    else {\n        const fetchInfo = await handleFetch(uri, opts)\n        const response = fetchInfo.response\n\n        info.response = response\n        if (response.ok) {\n            if (expectedType) {\n                const mimeType = response.headers.get(\"Content-Type\")\n                if (!mimeType.includes(expectedType)) throw new Error(`Expected Content Type ${expectedType} but received ${mimeType} for  ${uri}`)\n            }\n\n            info.buffer = fetchInfo.buffer\n            info.text.original = info.text.updated = enc.decode(info.buffer)\n        } else {\n            throw new Error(response.statusText)\n        }\n    }\n\n    return info\n}\n\nexport const find = async(uri, opts, callback) => {\n    \n     // Try Alternative File Paths\n     const transArray = transformations.get(uri)\n\n     let response;\n \n     if (transArray.length > 0) {\n         do {\n             const ext = transArray.shift()\n \n             const name = ext?.name ?? ext\n             const warning = (e) => {\n                 if (opts.debug) console.error(`Import using ${name ?? ext} transformation failed for ${uri}`)\n             }\n \n             const transformed = await handlers.transformation(uri, ext, opts)\n             const correctURI = pathUtils.get(transformed, opts.relativeTo)\n             const expectedType = (ext) ? null : 'application/javascript'\n             response = await callback(correctURI, opts, expectedType).then(res => {\n                if (opts.debug) console.warn(`Import using ${name ?? ext} transformation succeeded for ${uri}`)\n                return res\n            }).catch(warning)\n         } while (!response && transArray.length > 0)\n \n         if (!response) throw new Error(`No valid transformation found for ${uri}`)\n     }\n \n     // Get Specified URI Directly\n     else response = await callback(pathUtils.get(uri, opts.relativeTo), opts);\n\n    return response\n}\n\n\nexport const findModule = async (uri, opts) => {\n    const pathExt = pathUtils.extension(uri)\n    const isJSON = pathExt === \"json\";\n\n    const info = {}\n    await find(uri, opts, async (transformed) => {\n        info.uri = transformed\n        info.result = await (isJSON ? import(transformed, { assert: { type: \"json\" } }) : import(transformed))\n    })\n\n    return info\n}\n\n// Get ESM Module Text\nexport const findText = async (uri, opts) => await find(uri, opts, get)", "export const script = async (uri) => {\n    return await new Promise(((resolve, reject) => {\n\n        const script = document.createElement('script')\n\n        let r = false\n        script.onload = script.onreadystatechange = function () {\n            if (!r && (!this.readyState || this.readyState == 'complete')) {\n                r = true\n                resolve(window)\n            }\n        }\n\n        script.onerror = reject\n\n        script.src = uri;\n        document.body.insertAdjacentElement('beforeend', script)\n    }))\n}\n", "import * as pathUtils from './utils/path.js'\nimport * as encode from \"./utils/encode/index.js\";\nimport * as mimeTypes from \"./utils/mimeTypes.js\";\nimport * as compile from \"./utils/compile.js\"\nimport * as response from \"./utils/response.js\"\nimport * as nodeModules from './utils/nodeModules.js'\nimport * as errors from './utils/errors.js'\nimport * as polyfills from './utils/polyfills.js'\nimport * as sourceMap from './utils/sourceMap.js';\n\nif (!globalThis.REMOTEESM_BUNDLES) globalThis.REMOTEESM_BUNDLES = {global: {}} // Share references between loaded dataurl instances\nconst global = globalThis.REMOTEESM_BUNDLES.global\n\nconst noEncoding = `No buffer or text to bundle for`\n\n// Import ES6 Modules (and replace their imports with actual file imports!)\n// TODO: Handle exports without stalling...\n// const re = /[^\\n]*(?<![\\/\\/])(import|export)\\s+([ \\t]*(?:(?:\\* (?:as .+))|(?:[^ \\t\\{\\}]+[ \\t]*,?)|(?:[ \\t]*\\{(?:[ \\t]*[^ \\t\"'\\{\\}]+[ \\t]*,?)+\\}))[ \\t]*)from[ \\t]*(['\"])([^'\"\\n]+)(?:['\"])([ \\t]*assert[ \\t]*{[ \\n\\t]*type:[ \\n\\t]*(['\"])([^'\"\\n]+)(?:['\"])[\\n\\t]*})?/gm\nconst re = /[^\\n]*(?<![\\/\\/])(import)\\s+([ \\t]*(?:(?:\\* (?:as .+))|(?:[^ \\t\\{\\}]+[ \\t]*,?)|(?:[ \\t]*\\{(?:[ \\t]*[^ \\t\"'\\{\\}]+[ \\t]*,?)+\\}))[ \\t]*)from[ \\t]*(['\"])([^'\"\\n]+)(?:['\"])([ \\t]*assert[ \\t]*{[ \\n\\t]*type:[ \\n\\t]*(['\"])([^'\"\\n]+)(?:['\"])[\\n\\t]*})?;?/gm\nexport function get(url, opts=this.options){\n    const pathId = (url) ? pathUtils.pathId(url, opts) : undefined // Set Path ID\n    let ref = globalThis.REMOTEESM_BUNDLES[opts.collection]\n    if (!ref) ref = globalThis.REMOTEESM_BUNDLES[opts.collection] = {}\n    let bundle = ref[pathId]\n    if (!bundle)  bundle =  new Bundle(url, opts)\n    else if (opts) bundle.options = opts // Reset options\n    return bundle\n}\n\n\nexport default class Bundle {\n\n    filename = 'bundle.esmpile.js'\n\n    uri;\n\n    #url \n    get url() { return this.#url }\n    set url(url) {\n        const ESMPileInternalOpts = this.options._esmpile\n        if (!ESMPileInternalOpts.entrypoint) ESMPileInternalOpts.entrypoint = this\n\n        if (!this.uri) this.uri = url // set original uri\n\n        // Transform for absolute targeting\n        if (!url.includes(this.#options.relativeTo)) url = pathUtils.get(url, this.#options.relativeTo)\n        this.#url = url\n        const pathId = pathUtils.pathId(this.url, this.options)\n        if (this.name !== pathId) this.name = pathId // derive a name\n        this.updateCollection(this.options.collection)\n    }\n\n    status = null\n    #options\n    get options() {return this.#options}\n    set options(opts={}) {\n\n            if (!opts._esmpile) opts._esmpile = this.#options?._esmpile ?? {circular: new Set()} // keep internal information\n\n            \n            if (!opts.collection) opts.collection = this.#options?.collection // keep collection\n\n            this.#options = opts\n\n            if (!opts.output) opts.output = {}\n\n            // ------------------- Set Bundler -------------------\n            this.bundler = opts.bundler\n\n            // ------------------- Set Bundle Collection -------------------\n            this.updateCollection(this.options.collection)\n\n            // ------------------- Derived Properties -------------------\n            if (typeof opts?.callbacks?.progress?.file === 'function') this.callbacks.file = opts.callbacks.progress.file\n\n\n            // Default Fetch Options\n            if (!opts.fetch) opts.fetch = {}\n            opts.fetch = Object.assign({}, opts.fetch) // shallow copy\n            opts.fetch.signal = this.controller.signal\n    }\n\n    controller = new AbortController()\n\n    // ------------------- Toggle Bundle Encoding -------------------\n    #bundler;\n    get bundler() { return this.#bundler }\n    set bundler(bundler) {\n        this.setBundleInfo(bundler)\n        this.setBundler(bundler, false)\n    }\n\n    setBundleInfo = (bundler) => {\n        this.#options._esmpile.lastBundler = this.#bundler\n        this.#bundler = this.#options.bundler = bundler\n\n        const output = this.#options.output\n        if (bundler) {\n            output[bundler] = true // default bundler option to true\n            output.text = true\n        }\n\n        this.derived.compile = !this.#options.forceNativeImport && (output.text || output.datauri || output.objecturl)\n    }\n\n    setBundler = async (bundler, setInfo = true) => {\n            if (setInfo) this.setBundleInfo(bundler)\n\n            const innerInfo = this.#options._esmpile\n            const lastBundleType = innerInfo.lastBundle\n\n            const isSame = innerInfo.lastBundle === bundler\n            if (\n                !isSame  // if bundler has changed\n                || (innerInfo.lastBundle && isSame && !lastBundleType) // no last bundle type (when expected)\n            ) {\n\n                const entrypoint = innerInfo.entrypoint\n                if (bundler) {\n                    const entries = Array.from(this.dependencies.entries())\n                    await Promise.all((entries).map(async ([_, entry]) => {\n                        entry.bundler = bundler\n                        await entry.result\n                    })) // set bundler for all entries\n                }\n\n                const isComplete = ['success', 'failed']\n                if (isComplete.includes(entrypoint?.status)) {\n\n                    if (!bundler) this.result = await this.resolve() // Direct Import\n                    else if (lastBundleType) this.encoded = await this.bundle(lastBundleType) // Swap Bundler Type\n                    else this.result = await this.resolve() // Full Resolution\n                }\n            }\n    }\n\n    // Name Property\n    #name;\n    get name() { return this.#name }\n    set name (name) {\n\n        // set new name\n        if (name !== this.#name){\n\n            // remove existing reference\n            let collection = globalThis.REMOTEESM_BUNDLES[this.collection]\n            if (collection){\n                if (global[this.name] === collection[this.name]) delete global[this.name] // delete from global collection\n                delete collection[this.name] // delete from parent collection\n            }\n\n            this.#name = name\n\n            // set filename\n            let filename = name.split('/').pop()\n            const components = filename.split('.')\n            this.filename = [...components.slice(0,-1), 'esmpile', 'js'].join('.')\n\n\n            // register in global\n            if (!global[this.name]) global[this.name] = this\n            else if (\n                this.options.collection != 'global'\n                //  && this.options.debug\n            ) console.warn(`Duplicating global bundle (${this.name})`, this.name)\n        }\n    }\n\n    // Register Bundle in Collection\n    #collection;\n    get collection() { return this.#collection }\n    set collection(collection) {\n\n        // if (collection !== this.#collection) {\n        this.#collection = collection\n        let ref = globalThis.REMOTEESM_BUNDLES[collection]\n            if (!ref) ref = globalThis.REMOTEESM_BUNDLES[collection] = {}\n            if (this.name) {\n                if (!ref[this.name]) ref[this.name] = this\n                else if (\n                    ref[this.name] !== this\n                ) console.warn(`Trying to duplicate bundle in bundle ${collection} (${this.name})`, this.name)\n            } //else console.warn('No name to set collection')\n        // }\n    }\n\n    // Update Bundle\n    #text\n    #buffer\n    get text() {return this.#text}\n    set text(text) {\n        this.#text = text\n        this.encoded = this.bundle('text').catch(e => { \n            if (!e.message.includes(noEncoding)) throw e \n        }) \n    }\n\n    set buffer(buffer) {\n        this.#buffer = buffer\n        this.encoded = this.bundle('buffer').catch(e => { if (!e.message.includes(noEncoding)) throw e }) // New info creates new bundle\n    }\n\n    dependencies = new Map()\n    dependents = new Map()\n\n    get entries(){\n\n        let entries = []\n\n        const drill = (target) => {\n            target.dependencies.forEach(o => {\n                if (!entries.includes(o) && o !== this) {\n                    entries.push(o)\n                    drill(o)\n                }\n            })\n        }\n\n        drill(this)\n\n        return entries\n    }\n\n    encodings = {}\n\n    info = {}\n\n    imports = []\n\n    link = undefined\n    result = undefined\n\n    callbacks = {\n        file: undefined,\n    }\n\n    derived = {\n        compile: false,\n        dependencies: {n: 0, resolved: 0}\n    }\n\n    constructor(entrypoint, options={}) {\n\n        this.options = options\n        this.url = entrypoint\n    }\n\n    import = async () => {\n\n        this.status = 'importing'\n\n         const info = await response.findModule(this.url, this.options)\n         \n         // Direct import was successful\n         if (info?.result) return info.result\n         else this.status = 'fallback'\n    }\n\n    get = get\n\n    compile = async () => {\n\n        this.status = 'compiling'\n\n        await polyfills.ready // Make sure fetch is ready\n\n        try {\n            \n            const info = await response.findText(this.url, this.options).catch(e => { throw e })\n\n            try {\n\n                if (info){\n                    this.info = info\n                    this.url = this.info.uri // reset this bundle's name\n                    this.buffer = this.info.buffer\n                    await this.encoded // resolve after successful encoding  \n                }\n            }\n\n            // ------------------- Replace Nested Imports -------------------\n            catch (e) {\n\n                // ------------------- Get Import Details -------------------\n                this.imports = {} // permanent collection of imports\n                const imports = [] // temporary\n                const matches = Array.from(this.info.text.updated.matchAll(re))\n                matches.forEach(([original, prefix, command, delimiters, path]) => {\n\n                    if (path){\n                        const wildcard = !!command.match(/\\*\\s+as/);\n                        const variables = command.replace(/\\*\\s+as/, \"\").trim();\n\n                        const absolutePath = pathUtils.absolute(path)\n                        let name = (absolutePath) ? path : pathUtils.get(path, this.url);\n                        const absNode = nodeModules.path(this.options)\n                        name = name.replace(`${absNode}/`, '')\n    \n                        const info = {\n                            name,\n                            path,\n                            prefix,\n                            variables,\n                            wildcard,\n                            current: {\n                                line: original,\n                                path\n                            },\n                            original,\n                            counter: 0,\n                            bundle: null\n                        }\n            \n                        if (!this.imports[name]) this.imports[name] = [];\n                        this.imports[name].push(info)\n                        imports.push(info)\n                    }\n                })\n\n                this.derived.dependencies.resolved = 0\n                this.derived.dependencies.n = this.imports.length\n\n                // ------------------- Import Files Asynchronously -------------------\n                const promises = imports.map(async (info, i) => {\n                    await this.updateImport(info, i)\n                    this.derived.dependencies.resolved++\n                })\n\n                await Promise.all(promises)\n\n                this.text = this.info.text.updated // trigger recompilation from text\n            }\n\n        } \n        // ------------------- Catch Aborted Requests -------------------\n        catch (e) {\n            throw e\n        }\n\n        await this.encoded\n\n        return this.result\n    }\n\n    updateImportPath = (info, encoded) => {\n        \n        if (encoded === info.current.path) return\n        const { prefix, variables, wildcard, bundle } = info;\n\n        let newImport = '';\n        // ----------- Native Imports -----------\n        if (typeof encoded === \"string\") {\n            newImport = `${prefix} ${wildcard ? \"* as \" : \"\"}${variables} from \"${encoded}\"; // Imported from ${bundle.name}\\n\\n`\n\n            // // ----------- Dynamic Imports -----------\n            // const replaced = variables.replace('{', '').replace('}', '')\n            // const exportDefault = (replaced === variables) ? true : false\n            // const splitVars = variables.replace('{', '').replace('}', '').split(',').map(str => str.trim())\n\n            // const insertVariable = (variable, j) => {\n            //     let end = ''\n            //     if (!wildcard) {\n            //         if (exportDefault) end = `.default`\n            //         else end = `.${variable}`\n            //     }\n\n            //     const randomVarName = `remoteesm_datauri_${i}_${j}`\n            //     const encodedSplit = encoded.match(/.{1,100}/g)\n            //     this.info.text.updated = `const ${randomVarName} = ${JSON.stringify(encodedSplit)};\\n\\n${prefix === 'import' ? '' : 'export '}const ${variable} = (await import(${randomVarName}.join('')))${end};\\n\\n${this.info.text.updated}`;\n            // }\n\n            // splitVars.forEach(insertVariable)\n        }\n\n        // ----------- Passed by Reference (e.g. fallbacks) -----------\n        else {\n            \n            const replaced = variables.replace('{', '').replace('}', '')\n            const exportDefault = (replaced === variables) ? true : false\n            const splitVars = variables.replace('{', '').replace('}', '').split(',').map(str => str.trim())\n\n            const insertVariable = (variable) => {\n                let end = ''\n                if (!wildcard) {\n                    if (exportDefault) end = `.default`\n                    else end = `.${variable}`\n                }\n                newImport += `${prefix === 'import' ? '' : 'export '}const ${variable} = (await globalThis.REMOTEESM_BUNDLES[\"${bundle.collection}\"][\"${bundle.name}\"].result)${end};\\n\\n`;\n            }\n\n            splitVars.forEach(insertVariable)\n        }\n\n        this.info.text.updated = this.info.text.updated.replace(info.current.line, newImport)\n        info.current.line = newImport\n        info.current.path = encoded\n\n    }\n\n    updateImport = async (info) => {\n            let path = info.path        \n            let correctPath = info.name\n\n            // Get Dependency Bundle\n            const bundle = this.get(correctPath) \n            info.bundle = bundle\n\n            this.addDependency(bundle)\n    \n            // Get Bundle Value\n            if (!bundle.status) {\n                const options = { output: {}, ...this.options }\n                options.output.text = true // import from text\n                const newBundle = await this.get(correctPath, options)\n                await newBundle.resolve(path)\n            } else await bundle.result // wait for bundle to resolve\n    \n            // Update Original Input Texts\n            const encoded = await bundle.encoded \n\n            this.updateImportPath(info, encoded)\n\n            return bundle\n    }\n\n    notify = (done, failed) => {\n\n        const isDone = done !== undefined\n        const isFailed = failed !== undefined\n\n        // ------------------- Tell the User the File is Done -------------------\n        if (this.callbacks.file) this.callbacks.file(this.name, this.derived.dependencies.resolved, this.derived.dependencies.n, isDone ? this : undefined, isFailed ? failed : undefined) \n    }\n\n    get buffer() {return this.#buffer}\n\n\n    // Get Encoded Promise\n    bundle = (type=\"buffer\") => {\n\n        this.options._esmpile.lastBundle = type // register last bundle type\n        return new Promise (async (resolve, reject) => {\n\n            try {\n\n            let bufferOrText = (type === 'text') ? this.info.text.updated :  this.buffer \n\n                if (!bufferOrText) {\n                    if (this.info.fallback) this.encoded = this.info.fallback\n                    else reject(new Error(`${noEncoding} ${this.name}`))\n                }\n        \n                // Compile Code\n                const pathExt = pathUtils.extension(this.url)\n                let mimeType = mimeTypes.get(pathExt)\n                switch (mimeType) {\n                    case 'text/typescript':\n                        bufferOrText = compile.typescript(this.info, type)\n                        mimeType = mimeTypes.js\n                        break;\n                }\n            \n            \n                // Encode into a datauri and/or objecturl\n                const encodings = []\n                const output = this.options.output\n                if (output?.datauri) encodings.push('datauri')\n                if (output?.objecturl) encodings.push('objecturl')\n                for (let i in encodings) {\n                    const encoding = encodings[i]\n\n                    const encodedInfo = await encode[encoding](bufferOrText, this.url, mimeType)\n\n                    if (encodedInfo) {\n                        this.result = encodedInfo.module\n                        this.encodings[encoding] = await encodedInfo.encoded\n                    }\n                }\n\n                const encoded = (this.bundler === 'objecturl') ? this.encodings.objecturl : this.encodings.datauri\n\n                // Updating dependencies\n                const promises = Array.from(this.dependents.values()).map(dep => dep.updateDependency(this, encoded))\n                await Promise.all(promises)\n\n                resolve(encoded)\n            } catch (e) {\n                reject(e)\n            }\n        })\n    }\n\n    delete = () => {\n        if (this.objecturl) window.URL.revokeObjectURL(this.objecturl);\n    }\n\n    // ------------------- Dependency Management ------------------- //\n    addDependency = (o) => {\n\n        let foundCircular = false\n        if (this.dependents.has(o.url)) foundCircular = true\n        this.dependencies.set(o.url, o)\n        if (o.dependencies.has(this.url)) foundCircular = true \n        o.dependents.set(this.url, this)\n\n        // Abort for circular references before waiting\n        if(foundCircular) {\n            this.options._esmpile.circular.add(this.url, o.url)\n            this.options._esmpile.circular.add(o.url)\n            this.circular(o)\n            o.circular(this)\n        }\n    }\n\n    removeDependency = (o) => {\n        this.dependencies.delete(o.name)\n        o.dependents.delete(this.name)\n    }\n\n    updateDependency = async (o, encoding) => {\n        const infoArr = this.imports[o.url]\n        infoArr.forEach(info => this.updateImportPath(info, encoding))\n    }\n\n    // ------------------- Additional Helpers ------------------- //\n    updateCollection = (collection) => {\n        if (!collection) {\n            this.collection = this.options.collection = Object.keys(globalThis.REMOTEESM_BUNDLES).length\n        } else this.collection = collection\n    }\n\n    // ------------------- Download Bundle ------------------- //\n    download = async (path=this.filename) => {\n\n        if (this.bundler != 'datauri') await this.setBundler('datauri') // ensure that you can download\n\n        // Convert to ObjectURL\n        const mime = this.encodings.datauri.split(',')[0].split(':')[1].split(';')[0];\n        const binary = atob(this.encodings.datauri.split(',')[1]);\n        const array = [];\n        for (var i = 0; i < binary.length; i++) {\n        array.push(binary.charCodeAt(i));\n        }\n\n        const buffer = new Uint8Array(array)\n        const blob = new Blob([buffer], {type: mime});\n        const objecturl = URL.createObjectURL(blob)\n\n        // Download to your filesystem\n        if (globalThis.REMOTEESM_NODE){\n            await polyfills.ready\n            globalThis.fs.writeFileSync(path, buffer)\n            console.log(`Wrote bundle contents to ${path}`)\n        } \n        \n        // Download from the browser\n        else {\n\n            // Download on the Browser\n            var a = document.createElement(\"a\");\n            document.body.appendChild(a);\n            a.style = \"display: none\";\n            a.href = objecturl;\n            a.download = path;\n            a.click();\n        }\n    }\n\n    // ------------------- Handle Circular References ------------------- //\n    circular = async (o) => {\n        const result = await this.resolve().catch((e) => {\n            console.warn(`Circular dependency detected: Fallback to direct import for ${this.url} failed...`, e)\n            const message = `Circular dependency cannot be resolved: ${this.uri} <-> ${o.uri}.`\n            throw new Error(message)\n        })\n\n        console.warn(`Circular dependency detected: Fallback to direct import for ${this.url} was successful!`, result)\n    }\n\n    resolve = async (uri=this.uri) => {\n\n        // resetting resolution variables\n        this.status = 'resolving'\n        this.result = undefined\n        this.encoded = undefined\n\n        // define result promise\n        this.result = new Promise(async (resolve, reject) => {\n\n            let result;\n\n            const isCircular = this.options._esmpile.circular.has(this.url)\n            let isDirect = isCircular || !this.derived.compile\n\n            try {\n\n                result = (isDirect) ? await this.import().catch(async e => {\n                    if (this.#options.fallback === false) throw e\n                    else await this.setBundler('objecturl') // fallback to objecturl\n                }) : undefined // try to import natively\n\n                try {\n                    if (!result) {\n                        if (isCircular) throw new Error(`Failed to import ${this.url} natively.`)\n                        else result = await this.compile() // fallback to text compilation\n                    }\n                } \n                \n                // Handle Resolution Errors\n                catch (e) {\n\n                    if (this.options.fetch?.signal?.aborted) throw e\n\n                    // TODO: Can use these as defaults\n                    else {\n                        const noBase = pathUtils.absolute(uri) ? pathUtils.noBase(uri, this.options, true) : pathUtils.noBase(this.url, this.options, true)\n                        console.warn(`Failed to fetch ${uri}. Checking filesystem references...`);\n                        const filesystemFallback = this.options.filesystem?._fallbacks?.[noBase];\n                        if (filesystemFallback) {\n                            console.warn(`Got fallback reference (module only) for ${uri}.`);\n                            result = filesystemFallback;\n                            Object.defineProperty(info, 'fallback', { value: true, enumerable: false })\n                        } else {\n                            const middle = \"was not resolved locally. You can provide a direct reference to use in\";\n                            if (e.message.includes(middle)) throw e;\n                            else throw errors.create(uri, noBase);\n                        }\n                    }\n                }\n\n                 await this.encoded // ensure properly encoded\n                this.status = 'success'\n                this.notify(this)\n                resolve(result)\n            } catch (e) {\n                this.status = 'failed'               \n                 this.notify(null, e)\n                reject(e)\n            }\n        })\n\n        // Forward promise...\n        return this.result\n    }\n\n    sources = async () => await sourceMap.get(this.#url, this.#options, this.info.text.original)\n}", "import * as datauriEncoder from './datauri.js'\nimport * as objecturlEncoder from './objecturl.js'\n\nimport * as pathUtils from \"../path.js\";\nimport * as load from \"../load.js\";\nimport * as mimeTypes from '../mimeTypes.js'\n\nexport const datauri = async (...args) => await get(datauriEncoder.get, ...args)\nexport const objecturl = async (...args) => await get(objecturlEncoder.get, ...args)\n\nconst importEncoded = async (uri, isJSON) => await ((isJSON) ? import(uri, { assert: { type: \"json\" } }) : import(uri)).catch((e) => {\n    throw e\n});\n\nasync function get(encoder, input, uriForExtension, mimeType) {\n    \n    let encoded, module\n    if (!mimeType){\n        const pathExt = pathUtils.extension(uriForExtension)\n        mimeType = mimeTypes.get(pathExt)\n    }\n\n    let isJSON = mimeType === 'application/json'\n    \n    try {\n        encoded = encoder(input, mimeType);\n        module = await importEncoded(encoded, isJSON) // check if datauri will work to be imported. Otherwise try different methods and flag for import replacement\n    }\n\n    // Handle Exceptions\n    catch (e) {\n        encoded = encoder(input, mimeType, true);\n        if (mimeTypes.isJS(mimeType)) module = encoded = await catchFailedModule(encoded, e).catch((e) => {\n            // console.error('Failed to load module', path, info, e)\n            throw e\n        }); // javascript script tag imports\n        else module = encoded // audio / video assets\n    }\n\n    return {\n        encoded,\n        module\n    }\n}\n\nasync function catchFailedModule (uri, e){\n    if (\n        e.message.includes('The string to be encoded contains characters outside of the Latin1 range.') // cannot be represented as a datauri\n        || e.message.includes('Cannot set properties of undefined') // will not appropriately load to the window\n    ) return await load.script(uri)\n    else throw e\n}", "import { js } from '../mimeTypes.js'\n\nfunction _arrayBufferToBase64(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    for (let i = 0; i < len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return window.btoa(binary);\n}\n\n\nexport const get = (o, mimeType = js, safe = false) => {\n    const method = (typeof o === 'string') ? 'text' : 'buffer'\n    const base64 = (method === 'buffer') ? _arrayBufferToBase64(o) : btoa((safe) ? unescape(encodeURIComponent(o)) : o)\n    return `data:${mimeType};base64,` + base64\n}", "import { js } from '../mimeTypes.js'\n\nexport function get(input, mimeType = js) {\n    if (typeof input === 'string') input = new TextEncoder().encode(input);\n    const blob = new Blob([input], { type: mimeType })\n    return URL.createObjectURL(blob)\n}", "const tsconfig = {\n    compilerOptions: {\n        \"target\": \"ES2015\",\n        \"module\": \"ES2020\",\n        \"strict\": false,\n        \"esModuleInterop\": true\n    }\n}\n\nexport const typescript = (response, type = \"text\") => {\n    if (window.ts) {\n        const tsCode = (type !== 'buffer') ? response[type].updated : new TextDecoder().decode(response[type]);\n        response.text.updated = window.ts.transpile(tsCode, tsconfig.compilerOptions);\n        if (type === 'buffer') {\n            response.buffer = new TextEncoder().encode(response.text.updated); // encode to buffer\n            return response.buffer\n        } else return response.text.updated\n    } else throw new Error('Must load TypeScript extension to compile TypeScript files using remoteESM.load.script(...);')\n\n}", "// Node Polyfills\n\nexport let fetch;\nexport let fs;\nexport let Blob;\n\nconst isReady = new Promise(async (resolve, reject) => {\n\n    try {\n        if (typeof process === 'object') { //indicates node\n\n            // Fetch\n            if (!fetch) {\n                globalThis.REMOTEESM_NODE = true\n                fetch = globalThis.fetch = (await import('node-fetch')).default\n                if (typeof globalThis.fetch !== 'function') globalThis.fetch = fetch\n            }\n            // FS\n            if (!fs) fs = globalThis.fs = (await import('fs')).default\n\n            // Blob\n            if (!Blob) {\n                const buffer = (await import('node:buffer')).default\n                Blob = globalThis.Blob = buffer.Blob\n            }\n            resolve(true)\n        } else resolve(true)\n\n    } catch (err) {\n        reject(err)\n    }\n})\n\nexport const ready = isReady", "import * as pathUtils from \"./utils/path.js\";\nimport * as nodeModules from './utils/nodeModules.js'\nimport * as sourceMap from './utils/sourceMap.js'\nimport * as load from './utils/load.js'\nimport * as bundle from \"./Bundle.js\";\n\nexport const resolve = pathUtils.get\nexport const path = pathUtils\n\n// ------------- OOP Usage -------------\nexport const Bundle = bundle.default\n\n// ------------- Functional Usage -------------\nexport const compile = async (uri, opts = {}) => {\n    opts = Object.assign({}, opts) // copy options\n    const thisBundle = bundle.get(uri, opts) // grab or create bundle\n    await thisBundle.resolve()\n    return thisBundle.result;\n};\n\nexport default compile\n\nexport {\n    sourceMap,\n    nodeModules,\n    load,\n    bundle\n}"],
  "mappings": "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",
  "names": []
}
