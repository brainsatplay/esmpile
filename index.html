<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remote ESM</title>
    <style>

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            font-family: Arial, Helvetica, sans-serif;
        }

        i {
            font-size: 80%;
        }

        h1 {
            margin: 0;
        }

        section {
            padding: 50px;
        }

        li {
            padding: 10px;
        }

        #tests {
            padding: 10px;
        }


        #tests > div {
            border: 1px solid black;
            margin-bottom: 15px;
        }

        h2 {
            margin: 0;
            font-size: 15px;
        }

        button {
            padding: 5px 10px;
            color: white;
            border: 1px solid white;
            background: transparent;
            border-radius: 5px;
            margin-left: 10px;
            cursor: pointer;
        }

        #tests > div > div {
            width: 100%;
            padding: 10px 25px;
            background: black;
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;

        }

        ul {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 80%;
        }

        li {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        li > div > span {
            margin-left: 10px;
        }

        li > div {
            display: flex;
            align-items: center;
        }


        .progress-div {
            display: flex;
            align-items: center;
        }

        .progress-div span {
            margin-left: 10px;
            font-size: 70%;
        }

        .progress-circle {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: black;
            border: 1px solid white;
            margin-left: 15px;
        }

        .progress-circle.resolving {
            background: rgb(255, 237, 123);
        }

        .progress-circle.failed {
            background: rgb(255, 123, 123);
        }

        .progress-circle.resolved {
            background: rgb(141, 255, 123);
        }




    </style>
</head>

<body>
    <section>
        <h1>Remote ESM</h1>
        <i>View the Developer Console for outputs</i>
        <div id="tests"></div>
    </section>
</body>
<script type="module">

    import * as library from './src/index.js';

    let esm = library


    // ---------------- Set Global Variables ----------------
    const testDiv = document.getElementById('tests')
    const executable= './tests/index.js'
    const sourceURI = './dist/index.esm.js'

    // ---------------- Set Options ----------------
    const options = {}

    options.relativeTo = import.meta.url // Ensure appropriate relative paths are used
    options.bundle = null//'global' // Specify which bundle to reference. Specify 'global' to use same bundle across all imports. Don't specify to create a new bundle
    options.bundler = 'objecturl' // Specify what sort of link to import with | Can be 'datauri' (saveable) or 'objecturl' (runtime only)
    options.dependencies = {} // Track all file dependencies
    options.debug = false // Show debug messages

    options.onImport = async (path, info) => {

        // Resolve a Source Map
        if (path === sourceURI) {
            if (info.text) {
                let sourcemap = await esm.sourceMap.get(sourceURI, options, info.text.updated)
                if (sourcemap) {
                    console.log('source map!', sourcemap)
                } else console.log('No source map at specified location:', sourceURI)
            } else console.log('No text has been fetched to search for source map...')
        }

        // Execute a function
        if (path === executable) {
            info.module.imports.default()
        }

        // Create a worker
        if (path.includes('worker')) {
            console.log('Creating a dummy worker!', new Worker(info.objecturl, { type: "module" }))
        }
    }

    const forceText = { 
        output: {
            text: true 
        } 
    }

    const tests = {

        remote: {
            uri: 'https://raw.githubusercontent.com/garrettmflynn/phaser/main/scripts/player/update.js'
        },

        //---------------- Test Source Map Resolution for Self Distribution ----------------
        sourcemap: {
            uri: sourceURI
        },

        remote: {
            uri: 'https://raw.githubusercontent.com/garrettmflynn/phaser/main/scripts/player/update.js'
        },

        executable: {
            uri: executable,
        },

        node_module: {
            uri: 'device-decoder',
        },

        ['typescript + worker']: {
            uri: 'device-decoder/stream.big.worker.ts',
        }

    }

    // ---------------- Declare Utilities ----------------
    const importESM = async (path, options, opts) => {
        const res = await esm.compile(path, options);
        console.log(`---------------- ${opts.label} ----------------`)
        console.log(path, res)
        return res
    }

    // ---------------- Replace Library with Self Import ----------------
    esm = await importESM('./src/index.js', options, { label: 'self' });

    // ---------------- Preload the Typescript Service ----------------
    await esm.load.script('./extensions/typescriptServices.js');

    // ---------------- Run Tests ----------------
    for (let label in tests) {
        let test = tests[label]
        const div = document.createElement('div')
        const header = document.createElement('div')
        const ul = document.createElement('ul')
        const h2 = document.createElement('h2')
        const progressCircle = document.createElement('div')
        progressCircle.classList.add('progress-circle')
        const time = document.createElement('span')

        const h2Div = document.createElement('div')
        h2Div.classList.add('progress-div')

        const buttonDiv = document.createElement('div')
        const button = document.createElement('button')
        const fromText = document.createElement('button')

        h2.innerText = label
        button.innerText = 'Import'
        fromText.innerText = 'Import from Text'

        h2Div.appendChild(h2)
        h2Div.appendChild(progressCircle)
        h2Div.appendChild(time)

        buttonDiv.appendChild(button)
        buttonDiv.appendChild(fromText)

        header.appendChild(h2Div)
        header.appendChild(buttonDiv)

        div.appendChild(header)
        div.appendChild(ul)
        testDiv.appendChild(div)

        const onClick = async (override) => {

            progressCircle.classList.add('resolving')

            const selectedOptions = test.options ?? options

            const entries = {}

            const createEntry = (path) => {
                if (!entries[path]) {
                    const li = document.createElement('li')
                    const div = document.createElement('div')
                    const amount = document.createElement('span')
                    const status = document.createElement('span')
                    li.innerText = path
                    ul.appendChild(li)
                    div.appendChild(status)
                    div.appendChild(amount)
                    li.appendChild(div)

                    entries[path] = {li, amount, status}
                }
            }

            // Specify Callbacks Internally (to update ui)
            options.callbacks = {
                progress: {
                    file: (path, i, total, done, failed) => {
                        if (!entries[path]) createEntry(path)
                        if (done) entries[path].status.innerText = `Resolved`
                        else if (failed) entries[path].status.innerText = `Failed`
                        else {
                            entries[path].status.innerText = `Resolving`
                            let value = i;
                            if (total) value = `${100*value/total}%`
                            entries[path].amount.innerText = `${value}`
                        }
                    },
                    fetch: (path, i, total, done, failed, range) => {
                        if (!entries[path]) createEntry(path)
                        if (done) entries[path].status.innerText = `Fetched`
                        else if (failed) entries[path].status.innerText = `Failed`
                        else{
                            entries[path].status.innerText = `Fetching`
                            let value = i;
                            if (total) value = `${100*value/total}%`
                            entries[path].amount.innerText = `${value}${range ? ` of ${range}` : ''}`
                        }
                    }
                }
            }



            const fullOptions = Object.assign(Object.assign({}, options), override)

            const tic = performance.now()
            ul.innerHTML = '' // clear the list
            const res = await importESM(test.uri, fullOptions, { label }).catch(e => {
                console.warn(e)
                progressCircle.classList.add('failed') // resolution failed
            })
            const toc = performance.now()
            if (res) progressCircle.classList.add('resolved')
            time.innerHTML = `${(toc-tic).toFixed(3)}ms`


        }

        button.onclick = () => onClick()
        fromText.onclick = () => onClick(forceText)

    }

</script>

</html>