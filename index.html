<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESMpile</title>
    <style>

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            font-family: Arial, Helvetica, sans-serif;
        }

        nav {
            padding: 20px 35px;
            background-color: black;
            color: white;
        }

        i {
            font-size: 80%;
        }

        h1 {
            margin: 0;
        }

        section {
            padding: 25px;
        }

        li {
            padding: 10px;
        }

        #tests {
            padding: 10px;
        }


        #tests > div {
            border: 1px solid black;
            margin-bottom: 15px;
        }

        .h2-div {
            pointer-events: none;
        }

        .h2-div h2 {
            margin: 0;
            font-size: 15px;
        }

        .h2-div p {
            margin: 0;
            font-size: 10px;
        }
        
        .buttons button {
            padding: 5px 10px;
            color: white;
            border: 1px solid white;
            background: transparent;
            border-radius: 5px;
            margin-left: 10px;
            font-size: 70%;
            cursor: pointer;
        }

        button.inactive {
            cursor: default;
            opacity: 0.5;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #tests .header {
            width: 100%;
            padding: 10px;
            background: black;
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: height 0.5s;
            cursor: pointer;
        }

        .error {
            padding: 10px 15px;
            background:rgb(255, 191, 191);
            font-size: 80%;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }


        ul {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 80%;
            overflow: hidden;
        }

        li {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        li > div > * {
            margin-left: 10px;
        }

        li > div {
            display: flex;
            align-items: center;
        }


        .progress-div {
            display: flex;
            align-items: center;
        }

        .progress-div span {
            margin-left: 10px;
            font-size: 70%;
        }

        .progress-circle {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: black;
            border: 1px solid white;
            margin-left: 15px;
        }

        .progress-circle.resolving {
            background: rgb(255, 237, 123);
        }

        .progress-circle.failed {
            background: rgb(255, 123, 123);
        }

        .progress-circle.resolved {
            background: rgb(141, 255, 123);
        }




    </style>
</head>

<body>
    <nav><h1>ESMpile</h1></nav>
    <section>
        <div id="tests"></div>
    </section>
</body>
<script type="module">

    import * as library from './src/index.js';

    let esm = library

    // ---------------- Preload the Typescript Service ----------------
    await esm.load.script('./extensions/typescriptServices.min.js');

    // ---------------- Set Global Variables ----------------
    const testDiv = document.getElementById('tests')
    const entries = {}
    const displays = {}

    const createDisplay = (label, info) => {

        if (!displays[label]) {
            const div = document.createElement('div')
            const header = document.createElement('div')
            const error = document.createElement('div')
            error.classList.add('error')
            error.style.display = 'none'
            header.classList.add('header')

            const ul = document.createElement('ul')

            // Toggle List View
            header.onclick = () => {
                if (ul.style.height === '0px') ul.style.height = ``
                else ul.style.height = `0px`
            }

            const h2 = document.createElement('h2')
            const pathEl = document.createElement('p')
            const progressCircle = document.createElement('div')
            progressCircle.classList.add('progress-circle')
            const time = document.createElement('span')

            const h2Div = document.createElement('div')
            h2Div.classList.add('h2-div')
            h2Div.appendChild(h2)
            h2Div.appendChild(pathEl)


            const headerDiv = document.createElement('div')
            headerDiv.classList.add('progress-div')

            const buttonDiv = document.createElement('div')
            buttonDiv.classList.add('buttons')
            const button = document.createElement('button')
            const fromText = document.createElement('button')

            h2.innerText = label
            pathEl.innerText = info.uri

            button.innerText = 'Import'
            fromText.innerText = 'Compile'

            headerDiv.appendChild(h2Div)
            headerDiv.appendChild(progressCircle)
            headerDiv.appendChild(time)

            buttonDiv.appendChild(button)
            buttonDiv.appendChild(fromText)

            header.appendChild(h2Div)
            header.appendChild(buttonDiv)

            div.appendChild(header)
            div.appendChild(error)
            div.appendChild(ul)
            testDiv.appendChild(div)

            const display = displays[label] = {
                name: label,
                list: ul, 
                progress: progressCircle, 
                time, 
                buttons: {
                    direct: button,
                    text: fromText
                },
                error,
                entries: {}
            }

        }

        return displays[label]
    }

    const createEntry = (path, display) => {

        let entry = display.entries[path]
        
        if (!entry && display?.list) {
            const li = document.createElement('li')
            const div = document.createElement('div')
            const name = document.createElement('span')
            const amount = document.createElement('span')
            const status = document.createElement('span')

            const download = document.createElement('button')
            download.classList.add('inactive')
            download.innerText = 'Download'

            display.list.appendChild(li)
            div.appendChild(status)
            div.appendChild(amount)
            div.appendChild(download)

            li.appendChild(name)
            li.appendChild(div)

            entry = display.entries[path] = {
                li, 
                name, 
                amount, 
                status, 
                path, 
                display,
                download,
                reset: () => {
                    name.innerText = path
                    status.innerText = ''
                    amount.innerText = ''
                    download.classList.add('inactive')
                    display.list.style.height = ''
                },
                bundle: null
            }

            entry.reset()

            download.onclick = () => {
                console.log(entry)
                if (entry.bundle) entry.bundle.download()
            }

            if (!entries[path]) entries[path] = []
            entries[path].push(entry)
        }

        return entry
    }

    const executable= './tests/index.js'
    const sourceURI = './dist/index.esm.js'
    const selfURI = './src/index.js'


    // ---------------- Set Options ----------------
    const options = {}

    options.relativeTo = import.meta.url // Ensure appropriate relative paths are used
    options.bundle = null //'global' // Specify which bundle to reference. Specify 'global' to use same bundle across all imports. Don't specify to create a new bundle
    options.bundler = 'objecturl' // Specify what sort of link to import with | Can be 'datauri' (saveable) or 'objecturl' (runtime only)
    options.dependencies = {} // Track all file dependencies
    options.debug = false // Show debug messages
    options.callbacks = {progress: {}}
    options.callbacks.onfile = async (path, bundle) => {

        console.log(path, bundle)
        // Add Link to Entry
        if (bundle.link) {

            const entriesForPath = entries[path]
            if (entriesForPath) {

                entriesForPath.forEach(entry => {
                    entry.bundle = bundle
                    entry.download.classList.remove('inactive') // activate download button
                    entry.name.innerHTML = `<a href="${bundle.link}" target="_blank">${path}</a>`
                }) // Provide a link
            }
        }

        //---------------- Import Self and Use That as the Core Library ----------------
        if (bundle.info.original === selfURI) esm = bundle.result

        // Resolve a Source Map

        if (bundle.info.original === sourceURI) {
            if (bundle.text) {
                let sourcemap = await esm.sourceMap.get(sourceURI, options, bundle.text.updated)
                if (sourcemap) {
                    console.log('source map!', sourcemap)
                } else console.log('No source map at specified location:', sourceURI)
            } else console.log('No text has been fetched to search for source map...')
        }

        // Execute a function
        if (path === executable) {
            bundle.result.imports.default()
        }

        // Create a worker
        if (path.includes('worker')) {
            console.log('Creating a dummy worker!', new Worker(bundle.objecturl, { type: "module" }))
        }
    }

    // ---------------- Test Bundles ----------------
    // const res = await esm.compile('./tests/bundled/device.frontend.esm.esmpile.js', options)
    // const worker = await esm.compile('./tests/bundled/stream.big.worker.esmpile.js', options)

    const forceText = { 
        bundler: 'datauri', // Toggle between this more naturally...
        output: {
            text: true 
        } 
    }

    const tests = {

        self: {
            uri: selfURI
        },

        remote: {
            uri: 'https://raw.githubusercontent.com/garrettmflynn/phaser/main/scripts/player/update.js'
        },

        //---------------- Test Source Map Resolution for Self Distribution ----------------
        sourcemap: {
            uri: sourceURI
        },

        remote: {
            uri: 'https://raw.githubusercontent.com/garrettmflynn/phaser/main/scripts/player/update.js'
        },

        executable: {
            uri: executable,
        },

        node_module: {
            uri: 'device-decoder',
        },

        ['typescript + worker']: {
            uri: 'device-decoder/stream.big.worker.ts',
        }

    }

    
    // ---------------- Run Tests ----------------
    for (let label in tests) {

        let test = tests[label]
        const display = createDisplay(label, test)
        const entries = display.entries

        const onClick = async (override) => {

            // Reset Display
            for (let name in display.entries) display.entries[name].reset(true)

            display.progress.classList.add('resolving')

            const selectedOptions = test.options ?? options

            // Specify Callbacks Internally (to update ui)
            options.callbacks.progress.file = (path, i, total, done, failed) => {
                if (!entries[path]) createEntry(path, display)
                if (done) entries[path].status.innerText = `Resolved`
                else if (failed) entries[path].status.innerText = `Failed`
                else {
                    entries[path].status.innerText = `Resolving`
                    let value = i;
                    if (total) value = `${(100*value/total).toFixed(1)}%`
                    entries[path].amount.innerText = `${value}`
                }
            }

            options.callbacks.progress.fetch = (path, i, total, done, failed, range) => {
                if (!entries[path]) createEntry(path, display)
                if (done) entries[path].status.innerText = `Fetched`
                else if (failed) entries[path].status.innerText = `Failed`
                else{
                    entries[path].status.innerText = `Fetching`
                    let value = i;
                    if (total) value = `${(100*value/total).toFixed(1)}%`
                    entries[path].amount.innerText = `${value}${range ? ` of ${range}` : ''}`
                }
            }



            const fullOptions = Object.assign(Object.assign({}, options), override)

            const tic = performance.now()
            const res = await esm.compile(test.uri, fullOptions).catch(e => {
                display.error.innerText = `Compilation Error: ${e.message}`
                display.error.style.display = ""
                display.progress.classList.add('failed') // resolution failed
            })
            const toc = performance.now()

            if (res) display.progress.classList.add('resolved')
            display.time.innerHTML = `${(toc-tic).toFixed(3)}ms`

            return res
        }

        display.buttons.direct.onclick = () => onClick()
        display.buttons.text.onclick = () => onClick(forceText)


        if (label === 'self') display.buttons.direct.click() // auto-import self
    }


</script>

</html>