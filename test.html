<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remote ESM</title>
    <style>

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            font-family: Arial, Helvetica, sans-serif;
        }

        i {
            font-size: 80%;
        }

        h1 {
            margin: 0;
        }

        section {
            padding: 50px;
        }

        li {
            padding: 10px;
        }

        #tests {
            padding: 10px;
        }


        #tests > div {
            border: 1px solid black;
            margin-bottom: 15px;
        }

        h2 {
            margin: 0;
            font-size: 15px;
        }

        button {
            padding: 5px 10px;
            color: white;
            border: 1px solid white;
            background: transparent;
            border-radius: 5px;
            margin-left: 10px;
            cursor: pointer;
        }

        #tests > div > div {
            width: 100%;
            padding: 10px 25px;
            background: black;
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;

        }

        ul {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 80%;
        }

        li {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        li > div > span {
            margin-left: 10px;
        }

        li > div {
            display: flex;
            align-items: center;
        }


        .progress-div {
            display: flex;
            align-items: center;
        }

        .progress-div span {
            margin-left: 10px;
            font-size: 70%;
        }

        .progress-circle {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: black;
            border: 1px solid white;
            margin-left: 15px;
        }

        .progress-circle.resolving {
            background: rgb(255, 237, 123);
        }

        .progress-circle.failed {
            background: rgb(255, 123, 123);
        }

        .progress-circle.resolved {
            background: rgb(141, 255, 123);
        }




    </style>
</head>

<body>
    <section>
        <h1>Remote ESM</h1>
        <i>View the Developer Console for outputs</i>
        <div id="tests"></div>
    </section>
</body>
<script type="module">

    import * as library from './src/index.js';

    let esm = library


    // ---------------- Preload the Typescript Service ----------------
    await esm.load.script('./extensions/typescriptServices.js');


    // ---------------- Set Global Variables ----------------
    const testDiv = document.getElementById('tests')
    const entries = {}
    const displays = {}

    const createDisplay = (label, path) => {
        if (!displays[label]) {
            const div = document.createElement('div')
            const header = document.createElement('div')
            const ul = document.createElement('ul')
            const h2 = document.createElement('h2')
            const progressCircle = document.createElement('div')
            progressCircle.classList.add('progress-circle')
            const time = document.createElement('span')

            const h2Div = document.createElement('div')
            h2Div.classList.add('progress-div')

            const buttonDiv = document.createElement('div')
            const button = document.createElement('button')
            const fromText = document.createElement('button')

            h2.innerText = label
            button.innerText = 'Direct Import'
            fromText.innerText = 'From Text'

            h2Div.appendChild(h2)
            h2Div.appendChild(progressCircle)
            h2Div.appendChild(time)

            buttonDiv.appendChild(button)
            buttonDiv.appendChild(fromText)

            header.appendChild(h2Div)
            header.appendChild(buttonDiv)

            div.appendChild(header)
            div.appendChild(ul)
            testDiv.appendChild(div)

            displays[label] = {
                list: ul, 
                progress: progressCircle, 
                time, 
                buttons: {
                    direct: button,
                    text: fromText
                }
            }

        }

        return displays[label]
    }

    const createEntry = (path, display) => {
        if (!entries[path] && display?.list) {
            const li = document.createElement('li')
            const div = document.createElement('div')
            const amount = document.createElement('span')
            const status = document.createElement('span')
            li.innerText = path
            display.list.appendChild(li)
            div.appendChild(status)
            div.appendChild(amount)
            li.appendChild(div)

            entries[path] = {li, amount, status}
        }

        return entries[path]
    }

    const executable= './tests/index.js'
    const sourceURI = './dist/index.esm.js'
    const selfURI = './src/index.js'


    // ---------------- Set Options ----------------
    const options = {}

    options.relativeTo = import.meta.url // Ensure appropriate relative paths are used
    options.bundle = null//'global' // Specify which bundle to reference. Specify 'global' to use same bundle across all imports. Don't specify to create a new bundle
    options.bundler = 'objecturl' // Specify what sort of link to import with | Can be 'datauri' (saveable) or 'objecturl' (runtime only)
    options.dependencies = {} // Track all file dependencies
    options.debug = false // Show debug messages

    options.onImport = async (path, info) => {
        const link = info.objecturl ?? info.datauri

        console.log(info.original, info.module)
        // const entry = (!entries[path]) ? createEntry(path) : entries[path]
        // if (entry) entry.li.innerHTML = `<a href="${info.objecturl}" target="_blank">${path}</a>`
       

        if (info.original === selfURI) esm = info.module

        // Resolve a Source Map
        if (info.original === sourceURI) {
            if (info.text) {
                let sourcemap = await esm.sourceMap.get(sourceURI, options, info.text.updated)
                if (sourcemap) {
                    console.log('source map!', sourcemap)
                } else console.log('No source map at specified location:', sourceURI)
            } else console.log('No text has been fetched to search for source map...')
        }

        // Execute a function
        if (path === executable) {
            info.module.imports.default()
        }

        // Create a worker
        if (path.includes('worker')) {
            console.log('Creating a dummy worker!', new Worker(info.objecturl, { type: "module" }))
        }
    }

    const forceText = { 
        output: {
            text: true 
        } 
    }

    const tests = {

        self: {
            uri: selfURI
        },

        remote: {
            uri: 'https://raw.githubusercontent.com/garrettmflynn/phaser/main/scripts/player/update.js'
        },

        //---------------- Test Source Map Resolution for Self Distribution ----------------
        sourcemap: {
            uri: sourceURI
        },

        remote: {
            uri: 'https://raw.githubusercontent.com/garrettmflynn/phaser/main/scripts/player/update.js'
        },

        executable: {
            uri: executable,
        },

        node_module: {
            uri: 'device-decoder',
        },

        ['typescript + worker']: {
            uri: 'device-decoder/stream.big.worker.ts',
        }

    }

    
    // ---------------- Run Tests ----------------
    for (let label in tests) {

        let test = tests[label]
        const display = createDisplay(label, test)

        const onClick = async (override) => {

            display.progress.classList.add('resolving')

            const selectedOptions = test.options ?? options

            // Specify Callbacks Internally (to update ui)
            options.callbacks = {
                progress: {
                    file: (path, i, total, done, failed) => {
                        if (!entries[path]) createEntry(path, display)
                        if (done) entries[path].status.innerText = `Resolved`
                        else if (failed) entries[path].status.innerText = `Failed`
                        else {
                            entries[path].status.innerText = `Resolving`
                            let value = i;
                            if (total) value = `${(100*value/total).toFixed(1)}%`
                            entries[path].amount.innerText = `${value}`
                        }
                    },
                    fetch: (path, i, total, done, failed, range) => {
                        if (!entries[path]) createEntry(path, display)
                        if (done) entries[path].status.innerText = `Fetched`
                        else if (failed) entries[path].status.innerText = `Failed`
                        else{
                            entries[path].status.innerText = `Fetching`
                            let value = i;
                            if (total) value = `${(100*value/total).toFixed(1)}%`
                            entries[path].amount.innerText = `${value}${range ? ` of ${range}` : ''}`
                        }
                    }
                }
            }



            const fullOptions = Object.assign(Object.assign({}, options), override)

            const tic = performance.now()
            display.list.innerHTML = '' // clear the list
            const res = await esm.compile(test.uri, fullOptions).catch(e => {
                console.error('Failed ESMpilation', e)
                display.progress.classList.add('failed') // resolution failed
            })
            const toc = performance.now()
            if (res) display.progress.classList.add('resolved')
            display.time.innerHTML = `${(toc-tic).toFixed(3)}ms`
        }

        display.buttons.direct.onclick = () => onClick()
        display.buttons.text.onclick = () => onClick(forceText)

    }

    displays.self.buttons.direct.click() // auto-import self


</script>

</html>